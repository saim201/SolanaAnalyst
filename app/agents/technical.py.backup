import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
import json
import re
from datetime import datetime, timezone, date, timedelta
from typing import Dict, List, Optional, Any

from app.agents.base import BaseAgent, AgentState
from app.agents.llm import llm
from app.agents.db_fetcher import DataQuery
from app.database.data_manager import DataManager


SYSTEM_PROMPT = """You are a veteran swing trader analysing SOLANA (SOL/USDT) with 15 years of crypto market experience, specializing in 1-14 day holds.

YOUR TRADING PHILOSOPHY:
- Risk management is paramount: Never risk more than you can define
- Volume confirms everything: Low volume moves are suspect
- Trend is your friend: Trade with the trend, not against it
- Patience pays: No trade is better than a bad trade
- Be honest about uncertainty: When the picture is unclear, say so

YOUR ANALYSIS STYLE:
- Tell the STORY of what's happening, not just data points
- Think like a detective: What are buyers/sellers doing? Who's winning?
- Always explain the "why" behind moves
- Forward-looking: What happens next? What are we watching for?
- Speak to intermediate traders: Clear, actionable, no unnecessary jargon

SOLANA CONTEXT:
- SOL is a high-volatility L1 blockchain cryptocurrency
- Typical 15-30% pullbacks even in strong uptrends - this is normal
- Usually 0.75-0.90 correlation with BTC - when BTC moves, SOL often follows with amplification
"""


TECHNICAL_PROMPT = """
<market_data>
## CURRENT MARKET STATE
**Analysis Timestamp:** {analysis_timestamp}
**Price:** ${current_price:.2f} | **24h Change:** {change_24h:+.2f}%
**24h Range:** ${low_24h:.2f} - ${high_24h:.2f} (currently at {range_position_24h:.0%} of range)

---

## CORE INDICATORS

<trend_indicators>
**TREND:**
- EMA20: ${ema20:.2f} ({ema20_distance:+.1f}% from price)
- EMA50: ${ema50:.2f} ({ema50_distance:+.1f}% from price)
- 14d High: ${high_14d:.2f} | 14d Low: ${low_14d:.2f}
- Price Position in 14d Range: {price_position_14d:.0%}
</trend_indicators>

<momentum_indicators>
**MOMENTUM:**
- RSI(14): {rsi14:.1f} {rsi_status}
- MACD Line: {macd_line:.4f} | Signal: {macd_signal:.4f}
- MACD Histogram: {macd_histogram:.4f} ({macd_trend})
- RSI Divergence: {rsi_divergence_type} (strength: {rsi_divergence_strength:.2f})
</momentum_indicators>

<volume_indicators>
**VOLUME (CRITICAL - This can invalidate all other signals):**
- Volume Ratio: {volume_ratio:.2f}x average ({volume_classification})
- Buy Pressure (7d weighted): {weighted_buy_pressure:.1f}% (>50% = buyers dominating)
- Days Since Volume Spike (>1.5x): {days_since_volume_spike}
- Volume Trend: {volume_trend}
</volume_indicators>

<key_levels>
**KEY LEVELS:**
- Support 1: ${support1:.2f} ({support1_distance:.1f}% below current price)
- Support 2: ${support2:.2f} ({support2_distance:.1f}% below current price)
- Resistance 1: ${resistance1:.2f} ({resistance1_distance:.1f}% above current price)
- Resistance 2: ${resistance2:.2f} ({resistance2_distance:.1f}% above current price)
</key_levels>

---

## SITUATIONAL INDICATORS (Use if relevant)

<volatility_indicators>
**VOLATILITY:**
- ATR(14): ${atr:.2f} ({atr_percent:.1f}% of price) - {atr_interpretation}
- Bollinger Squeeze: {bb_squeeze_status} (ratio: {bb_squeeze_ratio:.1f}%)
</volatility_indicators>

<btc_correlation>
**BTC CORRELATION:**
- SOL-BTC Correlation (30d): {sol_btc_correlation:.2f} ({correlation_strength})
- BTC Trend: {btc_trend}
- BTC 30d Change: {btc_price_change_30d:+.1f}%
- Interpretation: {btc_interpretation}
</btc_correlation>

---

## RECENT PRICE ACTION (Last 7 Days with Timestamps)

<price_history>
{recent_price_action}
</price_history>

</market_data>

---

<instructions>
## YOUR TASK

Analyse the market data above using chain-of-thought reasoning. You MUST:

1. First, write your detailed reasoning inside <thinking> tags
2. Then, provide your final analysis as JSON inside <answer> tags

### THINKING PROCESS (inside <thinking> tags):

Work through these steps IN ORDER:

**Step 1 - MARKET STORY:** What's the big picture? Where are we in the trend cycle? Is this an uptrend, downtrend, or range?

**Step 2 - VOLUME CHECK:** Is there conviction behind the current move? CRITICAL: If volume_ratio < 0.7, this invalidates most other signals. State this clearly.

**Step 3 - MOMENTUM READ:** Is the move accelerating, steady, or fading? What does RSI + MACD tell us together?

**Step 4 - BTC CONTEXT:** Given the correlation level, how much does BTC's trend matter right now?

**Step 5 - SETUP IDENTIFICATION:** Is there a tradeable opportunity? Calculate specific entry, stop loss, take profit, and risk/reward ratio. If no good setup exists, explain why.

**Step 6 - RISK ASSESSMENT:** What could go wrong? What would invalidate your thesis?

**Step 7 - CONFIDENCE CALIBRATION:** What factors support your view? What concerns do you have? Arrive at a final confidence score (0.0-1.0).

### CRITICAL RULES:

- If volume_ratio < 0.7 (DEAD): You MUST recommend HOLD or WAIT
- If no support within 5% below current price: HOLD or WAIT
- If risk/reward < 1.5:1: HOLD or WAIT
- Always provide specific price levels, not vague guidance
- Be honest when the picture is unclear

### OUTPUT FORMAT:

After your thinking, output the final JSON inside <answer> tags. The JSON must follow this EXACT structure:

```json
{{
  "recommendation": "BUY|SELL|HOLD|WAIT",
  "confidence": 0.72,
  "market_condition": "TRENDING|RANGING|VOLATILE|QUIET",

  "summary": "2-3 sentences: What's happening and what to do. Be specific and actionable.",

  "thinking": [
    "Market story: [your observation]",
    "Volume assessment: [your observation]",
    "Momentum read: [your observation]",
    "BTC context: [your observation]",
    "Setup evaluation: [your observation]",
    "Key conclusion: [your conclusion]"
  ],

  "analysis": {{
    "trend": {{
      "direction": "BULLISH|BEARISH|NEUTRAL",
      "strength": "STRONG|MODERATE|WEAK",
      "detail": "1-2 sentences max"
    }},
    "momentum": {{
      "direction": "BULLISH|BEARISH|NEUTRAL",
      "strength": "STRONG|MODERATE|WEAK",
      "detail": "1-2 sentences max"
    }},
    "volume": {{
      "quality": "STRONG|ACCEPTABLE|WEAK|DEAD",
      "ratio": 0.82,
      "detail": "1-2 sentences max"
    }}
  }},

  "trade_setup": {{
    "viability": "VALID|WAIT|INVALID",
    "entry": 184.00,
    "stop_loss": 176.50,
    "take_profit": 198.00,
    "risk_reward": 1.8,
    "support": 184.00,
    "resistance": 195.00,
    "current_price": 188.50,
    "timeframe": "3-5 days"
  }},

  "action_plan": {{
    "primary": "Main action to take",
    "alternative": "Alternative if primary doesn't trigger",
    "if_in_position": "Guidance for existing holders",
    "avoid": "What NOT to do"
  }},

  "watch_list": {{
    "next_24h": ["Item 1", "Item 2", "Item 3"],
    "next_48h": ["Item 1", "Item 2", "Item 3"]
  }},

  "invalidation": [
    "Condition 1 that kills the thesis",
    "Condition 2 that kills the thesis"
  ],

  "confidence_reasoning": {{
    "supporting": ["Factor 1", "Factor 2", "Factor 3"],
    "concerns": ["Concern 1", "Concern 2", "Concern 3"],
    "assessment": "One sentence explaining final confidence score"
  }}
}}
```

IMPORTANT NOTES:
- Write your full reasoning in <thinking> tags FIRST
- Then output ONLY valid JSON in <answer> tags
- All price values should be numbers, not strings
- Confidence should be between 0.0 and 1.0
- If recommending HOLD/WAIT, set entry/stop_loss/take_profit to null but still provide support/resistance/current_price
</instructions>
"""


# ===== HELPER FUNCTIONS =====

def calculate_distance_percent(current: float, level: float) -> float:
    """Calculate percentage distance from current price to a level."""
    if current == 0:
        return 0.0
    return ((level - current) / current) * 100


def get_btc_interpretation(correlation: float, btc_trend: str) -> str:
    """Generate human-readable BTC correlation interpretation."""
    if correlation >= 0.75:
        if btc_trend == "BULLISH":
            return "High correlation + bullish BTC = supportive for SOL upside"
        elif btc_trend == "BEARISH":
            return "High correlation + bearish BTC = headwind for SOL"
        else:
            return "High correlation but BTC neutral - watch BTC for direction"
    elif correlation >= 0.5:
        return "Moderate correlation - SOL may diverge from BTC short-term"
    else:
        return "Low correlation - SOL trading independently of BTC"


def get_rsi_status(rsi: float) -> str:
    """Get human-readable RSI status."""
    if rsi >= 70:
        return "(OVERBOUGHT - potential reversal)"
    elif rsi >= 60:
        return "(Bullish, approaching overbought)"
    elif rsi <= 30:
        return "(OVERSOLD - potential bounce)"
    elif rsi <= 40:
        return "(Bearish, approaching oversold)"
    else:
        return "(Neutral zone)"


def get_macd_trend(histogram: float, prev_histogram: float = None) -> str:
    """Describe MACD histogram trend."""
    if histogram > 0:
        return "Positive - bullish momentum"
    elif histogram < 0:
        return "Negative - bearish momentum"
    else:
        return "Neutral"


def get_atr_interpretation(atr_percent: float) -> str:
    """Interpret ATR as volatility context."""
    if atr_percent >= 8:
        return "HIGH volatility - expect large swings"
    elif atr_percent >= 4:
        return "MODERATE volatility - normal for SOL"
    else:
        return "LOW volatility - potential breakout building"


def get_volume_trend(buy_pressure: float, volume_ratio: float) -> str:
    """Describe overall volume trend."""
    if volume_ratio < 0.7:
        return "DEAD - No conviction, signals unreliable"
    elif volume_ratio < 1.0:
        if buy_pressure > 55:
            return "Below average but buyers active"
        elif buy_pressure < 45:
            return "Below average with selling pressure"
        else:
            return "Below average, neutral pressure"
    else:
        if buy_pressure > 55:
            return "Above average with strong buying"
        elif buy_pressure < 45:
            return "Above average but sellers dominating"
        else:
            return "Above average, balanced"


def get_correlation_strength(correlation: float) -> str:
    """Classify correlation strength."""
    if correlation >= 0.8:
        return "VERY STRONG"
    elif correlation >= 0.6:
        return "STRONG"
    elif correlation >= 0.4:
        return "MODERATE"
    else:
        return "WEAK"


def format_recent_price_action(candles: list, limit: int = 7) -> str:
    """Format recent daily candles with timestamps for context."""
    if not candles:
        return "No recent data available"

    lines = []
    for candle in candles[-limit:]:
        # Get date
        date_str = candle.get('open_time', 'N/A')
        if hasattr(date_str, 'strftime'):
            formatted_date = date_str.strftime('%Y-%m-%d (%a)')
        elif isinstance(date_str, str):
            try:
                dt = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                formatted_date = dt.strftime('%Y-%m-%d (%a)')
            except:
                formatted_date = date_str[:10] if len(date_str) >= 10 else date_str
        else:
            formatted_date = str(date_str)

        o = candle.get('open', 0)
        h = candle.get('high', 0)
        l = candle.get('low', 0)
        c = candle.get('close', 0)
        vol = candle.get('volume', 0)
        taker_buy = candle.get('taker_buy_base', 0)

        change = ((c - o) / o * 100) if o > 0 else 0
        buy_ratio = (taker_buy / vol * 100) if vol > 0 else 50
        candle_type = "üü¢ BULLISH" if c >= o else "üî¥ BEARISH"

        lines.append(
            f"  {formatted_date}: {candle_type} | "
            f"Open: ${o:.2f} ‚Üí Close: ${c:.2f} ({change:+.1f}%) | "
            f"Range: ${l:.2f}-${h:.2f} | "
            f"Vol: {vol:,.0f} | Buy%: {buy_ratio:.0f}%"
        )

    return "\n".join(lines)


def calculate_price_position_in_range(current: float, high_14d: float, low_14d: float) -> float:
    """Calculate where current price sits in 14d range (0-100%)."""
    range_size = high_14d - low_14d
    if range_size == 0:
        return 0.5
    return (current - low_14d) / range_size


# ===== TECHNICAL AGENT CLASS =====

class TechnicalAgent(BaseAgent):
    def __init__(self):
        super().__init__(
            model="claude-sonnet-4-20250514",
            temperature=0.3
        )

    @staticmethod
    def detect_candle_pattern(candle: dict) -> str:
        open_p = candle['open']
        close_p = candle['close']
        high_p = candle['high']
        low_p = candle['low']

        body = abs(close_p - open_p)
        range_total = high_p - low_p

        if range_total == 0:
            return "NONE"

        body_ratio = body / range_total

        # Doji: small body (<10% of range)
        if body_ratio < 0.1:
            return "DOJI"

        # Hammer/Inverted Hammer: small body, long wick
        upper_wick = high_p - max(open_p, close_p)
        lower_wick = min(open_p, close_p) - low_p

        if lower_wick > body * 2 and upper_wick < body:
            return "HAMMER" if close_p > open_p else "HANGING_MAN"

        if upper_wick > body * 2 and lower_wick < body:
            return "INVERTED_HAMMER" if close_p > open_p else "SHOOTING_STAR"

        # Engulfing
        # Would need previous candle for this

        return "NONE"

    @staticmethod
    def format_daily_ohlc(candles: list) -> str:
        if not candles:
            return "No data available"

        lines = []
        for candle in candles[-14:]:
            date = candle.get('open_time', 'N/A')
            o = candle.get('open', 0)
            h = candle.get('high', 0)
            l = candle.get('low', 0)
            c = candle.get('close', 0)
            volume = candle.get('volume', 0)
            taker_buy_base = candle.get('taker_buy_base', 0)

            change = ((c - o) / o * 100) if o > 0 else 0
            buy_ratio = (taker_buy_base / volume * 100) if volume > 0 else 50.0

            lines.append(
                f"  {date}: O=${o:.2f} H=${h:.2f} L=${l:.2f} C=${c:.2f} ({change:+.1f}%) | "
                f"Vol={volume:,.0f} BuyPressure={buy_ratio:.1f}%"
            )

        return "\n".join(lines)



    @staticmethod
    def format_4h_candles(candles: list) -> str:
        if not candles:
            return "No data available"

        lines = []
        for candle in candles[-12:]:
            time = candle.get('open_time', 'N/A')
            o = candle.get('open', 0)
            c = candle.get('close', 0)
            change = ((c - o) / o * 100) if o > 0 else 0
            pattern = TechnicalAgent.detect_candle_pattern(candle)

            pattern_str = f" [{pattern}]" if pattern != "NONE" else ""
            lines.append(f"  {time}: ${c:.2f} ({change:+.1f}%){pattern_str}")

        return "\n".join(lines)



    @staticmethod
    def format_volume_progression(candles: list) -> str:
        if not candles or len(candles) < 14:
            return "Insufficient data"

        recent = candles[-14:]
        volumes = [c.get('volume', 0) for c in recent]

        first_half_avg = sum(volumes[:7]) / 7
        second_half_avg = sum(volumes[7:]) / 7
        volume_trend = "INCREASING" if second_half_avg > first_half_avg * 1.1 else "DECREASING" if second_half_avg < first_half_avg * 0.9 else "STABLE"

        first_half_buy = []
        second_half_buy = []

        for i, candle in enumerate(recent):
            volume = candle.get('volume', 0)
            taker_buy = candle.get('taker_buy_base', 0)
            buy_ratio = (taker_buy / volume * 100) if volume > 0 else 50.0

            if i < 7:
                first_half_buy.append(buy_ratio)
            else:
                second_half_buy.append(buy_ratio)

        avg_buy_first = sum(first_half_buy) / 7
        avg_buy_second = sum(second_half_buy) / 7
        buy_trend = "STRENGTHENING" if avg_buy_second > avg_buy_first + 3 else "WEAKENING" if avg_buy_second < avg_buy_first - 3 else "STABLE"

        latest = recent[-1]
        latest_buy = (latest.get('taker_buy_base', 0) / latest.get('volume', 1) * 100)

        return (
            f"  Volume Trend: {volume_trend}\n"
            f"  Recent 7d Avg: {second_half_avg:,.0f} ({((second_half_avg/first_half_avg - 1) * 100):+.1f}% vs prior 7d)\n"
            f"  Buying Pressure Trend: {buy_trend}\n"
            f"  Recent 7d Avg: {avg_buy_second:.1f}% (prior 7d: {avg_buy_first:.1f}%)\n"
            f"  Latest: {latest_buy:.1f}% (>50% = buyers control)"
        )



    @staticmethod
    def detect_patterns_at_levels(candles: list, support: float, resistance: float) -> str:
        if not candles or len(candles) < 2:
            return "Insufficient data"

        patterns = []
        recent = candles[-5:]

        for candle in recent:
            low = candle.get('low', 0)
            high = candle.get('high', 0)

            if support and abs(low - support) / support < 0.02:
                pattern = TechnicalAgent.detect_candle_pattern(candle)
                if pattern != "NONE":
                    patterns.append(f"  {pattern} at support ${support:.2f}")

            if resistance and abs(high - resistance) / resistance < 0.02:
                pattern = TechnicalAgent.detect_candle_pattern(candle)
                if pattern != "NONE":
                    patterns.append(f"  {pattern} at resistance ${resistance:.2f}")

        return "\n".join(patterns) if patterns else "  No significant patterns at key levels"



    def execute(self, state: AgentState) -> AgentState:
        with DataQuery() as dq:
            ticker = dq.get_ticker_data()
            if not ticker:
                raise ValueError("No ticker data available")

            indicators_data = dq.get_indicators_data()
            if not indicators_data:
                raise ValueError("No indicators data available")

            daily_candles = dq.get_candlestick_data(days=14)  # Last 14 days
            intraday_4h = dq.get_intraday_candles(limit=12)  # Last 48h of 4h candles

        current_price = float(ticker.get('lastPrice', 0))
        change_24h = float(ticker.get('priceChangePercent', 0))
        high_24h = float(ticker.get('highPrice', 0))
        low_24h = float(ticker.get('lowPrice', 0))

        range_24h = high_24h - low_24h
        if range_24h > 0:
            range_position_24h = (current_price - low_24h) / range_24h
        else:
            range_position_24h = 0.5

        ema20 = float(indicators_data.get('ema20', 0))
        ema50 = float(indicators_data.get('ema50', 0))
        ema200 = float(indicators_data.get('ema200', 0))
        kijun_sen = float(indicators_data.get('kijun_sen', 0))
        high_14d = float(indicators_data.get('high_14d', 0))
        low_14d = float(indicators_data.get('low_14d', 0))

        rsi14 = float(indicators_data.get('rsi14', 50))
        rsi_divergence_type = indicators_data.get('rsi_divergence_type', 'NONE')
        rsi_divergence_strength = float(indicators_data.get('rsi_divergence_strength', 0))
        stoch_rsi = float(indicators_data.get('stoch_rsi', 0.5))

        macd_line = float(indicators_data.get('macd_line', 0))
        macd_signal = float(indicators_data.get('macd_signal', 0))
        macd_histogram = float(indicators_data.get('macd_histogram', 0))

        volume_ratio = float(indicators_data.get('volume_ratio', 1.0))
        volume_classification = indicators_data.get('volume_classification', 'ACCEPTABLE')
        volume_trading_allowed = indicators_data.get('volume_trading_allowed', True)
        volume_confidence_multiplier = float(indicators_data.get('volume_confidence_multiplier', 1.0))
        days_since_volume_spike = int(indicators_data.get('days_since_volume_spike', 999))

        volume_24h = float(ticker.get('volume', 0))
        volume_ma20 = float(indicators_data.get('volume_ma20', 1))
        volume_surge_24h = volume_24h / volume_ma20 if volume_ma20 > 0 else 1.0

        atr = float(indicators_data.get('atr', 0))
        atr_percent = float(indicators_data.get('atr_percent', 0))
        bb_upper = float(indicators_data.get('bb_upper', 0))
        bb_lower = float(indicators_data.get('bb_lower', 0))
        bb_squeeze_active = indicators_data.get('bb_squeeze_active', False)
        bb_squeeze_ratio = float(indicators_data.get('bb_squeeze_ratio', 0))

        vwap = float(indicators_data.get('vwap', 0))
        vwap_distance = float(indicators_data.get('vwap_distance', 0))
        weighted_buy_pressure = float(indicators_data.get('weighted_buy_pressure', 50.0))

        sol_btc_correlation = float(indicators_data.get('sol_btc_correlation', 0))
        btc_correlation_strength = indicators_data.get('btc_correlation_strength', 'UNKNOWN')
        btc_trend = indicators_data.get('btc_trend', 'UNKNOWN')
        btc_price_change_30d = float(indicators_data.get('btc_price_change_30d', 0))

        support1 = float(indicators_data.get('support1') or 0)
        support1_percent = float(indicators_data.get('support1_percent') or 0)
        support2 = float(indicators_data.get('support2') or 0)
        support2_percent = float(indicators_data.get('support2_percent') or 0)

        resistance1 = float(indicators_data.get('resistance1') or 0)
        resistance1_percent = float(indicators_data.get('resistance1_percent') or 0)
        resistance2 = float(indicators_data.get('resistance2') or 0)
        resistance2_percent = float(indicators_data.get('resistance2_percent') or 0)

        pivot_weekly = float(indicators_data.get('pivot_weekly') or 0)
        fib_382 = float(indicators_data.get('fib_level_382', 0))
        fib_618 = float(indicators_data.get('fib_level_618', 0))

        daily_ohlc_text = self.format_daily_ohlc(daily_candles)
        intraday_4h_text = self.format_4h_candles(intraday_4h)
        volume_progression_text = self.format_volume_progression(daily_candles)
        candle_patterns_text = self.detect_patterns_at_levels(
            daily_candles,
            support1 if support1 > 0 else None,
            resistance1 if resistance1 > 0 else None
        )

        full_prompt = SYSTEM_PROMPT + "\n\n" + TECHNICAL_PROMPT.format(
            current_price=current_price,
            change_24h=change_24h,
            high_24h=high_24h,
            low_24h=low_24h,
            range_position_24h=range_position_24h,
            daily_ohlc=daily_ohlc_text,
            intraday_4h=intraday_4h_text,
            volume_progression=volume_progression_text,
            candle_patterns=candle_patterns_text,
            ema20=ema20,
            ema50=ema50,
            ema200=ema200,
            kijun_sen=kijun_sen,
            high_14d=high_14d,
            low_14d=low_14d,
            rsi14=rsi14,
            rsi_divergence_type=rsi_divergence_type,
            rsi_divergence_strength=rsi_divergence_strength,
            stoch_rsi=stoch_rsi,
            macd_line=macd_line,
            macd_signal=macd_signal,
            macd_histogram=macd_histogram,
            volume_ratio=volume_ratio,
            volume_classification=volume_classification,
            volume_trading_allowed=volume_trading_allowed,
            volume_confidence_multiplier=volume_confidence_multiplier,
            days_since_volume_spike=days_since_volume_spike,
            volume_surge_24h=volume_surge_24h,
            vwap=vwap,
            vwap_distance=vwap_distance,
            weighted_buy_pressure=weighted_buy_pressure,
            atr=atr,
            atr_percent=atr_percent,
            bb_upper=bb_upper,
            bb_lower=bb_lower,
            bb_squeeze_active=bb_squeeze_active,
            bb_squeeze_ratio=bb_squeeze_ratio,
            support1=support1,
            support1_percent=support1_percent,
            support2=support2,
            support2_percent=support2_percent,
            resistance1=resistance1,
            resistance1_percent=resistance1_percent,
            resistance2=resistance2,
            resistance2_percent=resistance2_percent,
            pivot_weekly=pivot_weekly,
            fib_382=fib_382,
            fib_618=fib_618,
            sol_btc_correlation=sol_btc_correlation,
            btc_correlation_strength=btc_correlation_strength,
            btc_trend=btc_trend,
            btc_price_change_30d=btc_price_change_30d,
        )

        response = llm(
            full_prompt,
            model=self.model,
            temperature=self.temperature,
            max_tokens=4096
        )

        try:
            thinking_match = re.search(r'<thinking>(.*?)</thinking>', response, re.DOTALL)
            thinking = thinking_match.group(1).strip() if thinking_match else ""
            
            answer_match = re.search(r'<answer>(.*?)</answer>', response, re.DOTALL)
            if answer_match:
                answer_json = answer_match.group(1).strip()
            else:
                json_match = re.search(r'\{.*\}', response, re.DOTALL)
                if json_match:
                    answer_json = json_match.group(0)
                else:
                    raise ValueError("No JSON found in response")
            
            answer_json = answer_json.strip()
            answer_json = re.sub(r'^```json\s*', '', answer_json)
            answer_json = re.sub(r'\s*```$', '', answer_json)
            first_brace = answer_json.find('{')
            last_brace = answer_json.rfind('}')
            if first_brace != -1 and last_brace != -1:
                answer_json = answer_json[first_brace:last_brace+1]
            
            answer_json = answer_json.replace('"', '"').replace('"', '"')
            answer_json = answer_json.replace(''', "'").replace(''', "'")
            answer_json = re.sub(r'[\x00-\x1F\x7F]', '', answer_json)

            try:
                analysis = json.loads(answer_json)
            except json.JSONDecodeError as json_err:
                print(f"JSON Parse Error: {json_err}")
                print(f"Sanitized JSON (first 500 chars): {answer_json[:500]}")
                print(f"Sanitized JSON (around error position): {answer_json[max(0, json_err.pos-100):json_err.pos+100]}")
                raise

            timestamp = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


            state['technical'] = {
                'timestamp': timestamp,
                'recommendation': analysis.get('recommendation', 'HOLD'),
                'confidence': float(analysis.get('confidence', 0.5)),
                'timeframe': analysis.get('timeframe', '1-7 days'),
                'key_signals': analysis.get('key_signals', []),
                'entry_level': analysis.get('entry_level'),
                'stop_loss': analysis.get('stop_loss'),
                'take_profit': analysis.get('take_profit'),
                'reasoning': analysis.get('reasoning', ''),
                'confidence_breakdown': analysis.get('confidence_breakdown', {}),
                'recommendation_summary': analysis.get('recommendation_summary', ''),
                'watch_list': analysis.get('watch_list', {}),
                'indicators_analysis': analysis.get('indicators_analysis', {}),
                'btc_correlation_impact': analysis.get('btc_correlation_impact', {}),
                'thinking': thinking if thinking else ''
            }

            with DataManager() as dm:
                dm.save_technical_analysis(data=state['technical'])


        except (json.JSONDecodeError, ValueError) as e:
            print(f"‚ö†Ô∏è  Technical agent parsing error: {e}")
            print(f"Response: {response[:300]}")

            timestamp = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

            state['technical'] = {
                'timestamp': timestamp,
                'recommendation': 'HOLD',
                'confidence': 0.0,
                'reasoning': f"Analysis parsing error: {str(e)[:100]}",
                'key_signals': [],
                'entry_level': None,
                'stop_loss': None,
                'take_profit': None,
                'timeframe': 'N/A',
                'confidence_breakdown': {},
                'recommendation_summary': 'Error occurred during analysis',
                'watch_list': {},
                'indicators_analysis': {},
                'btc_correlation_impact': {},
                'thinking': ''
            }

            # Save fallback data to database
            try:
                with DataManager() as dm:
                    dm.save_technical_analysis(data=state['technical'])
            except Exception as save_err:
                print(f"‚ö†Ô∏è  Failed to save fallback technical analysis: {save_err}")

        return state


if __name__ == "__main__":
    agent = TechnicalAgent()
    test_state = AgentState()
    result = agent.execute(test_state)
    print("\n===== TECHNICAL AGENT OUTPUT =====")
    print(json.dumps(result, indent=2, ensure_ascii=False))
